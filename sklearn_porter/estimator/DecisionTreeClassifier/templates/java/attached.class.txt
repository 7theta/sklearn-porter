/**
 * This file is generated by https://github.com/nok/sklearn-porter/
 *
 * Estimator:
 *     {estimator_name}
 *
 * Documentation:
 *     {estimator_url}
 *
 * Usage:
 *     1. Compile the generated source code:
 *         $ javac {class_name}.java
 *     2. Execute a prediction:
 *         $ java {class_name} <feature_1>  ... <feature_{n_features}>
 */

class {class_name} {{

    private int[] lefts;
    private int[] rights;
    private double[] thresholds;
    private int[] indices;
    private int[][] classes;

    public {class_name}(int[] lefts, int[] rights, double[] thresholds, int[] indices, int[][] classes) {{
        this.lefts = lefts;
        this.rights = rights;
        this.thresholds = thresholds;
        this.indices = indices;
        this.classes = classes;
    }}

    private int predict(double[] features, int node) {{
        if (this.thresholds[node] != -2) {{
            if (features[this.indices[node]] <= this.thresholds[node]) {{
                return predict(features, this.lefts[node]);
            }} else {{
                return predict(features, this.rights[node]);
            }}
        }}
        return max(this.classes[node]);
    }}

    public int predict(double[] features) {{
        return this.predict(features, 0);
    }}

    private int max(int[] nums) {{
        int index = 0;
        for (int i = 0; i < nums.length; i++) {{
            index = nums[i] > nums[index] ? i : index;
        }}
        return index;
    }}

    private double[] predictProba(double[] features, int node) {{
        if (this.thresholds[node] != -2) {{
            if (features[this.indices[node]] <= this.thresholds[node]) {{
                return this.predictProba(features, this.lefts[node]);
            }} else {{
                return this.predictProba(features, this.rights[node]);
            }}
        }}
        return norm(this.classes[node]);
    }}

    public double[] predictProba (double[] features) {{
        return this.predictProba(features, 0);
    }}

    private double[] norm(int[] nums) {{
        double[] result = new double[nums.length];
        double sum = 0.;
        for (int i = 0; i < nums.length; i++) {{
            sum += nums[i];
        }}
        if(sum == 0) {{
            for (int i = 0; i < nums.length; i++){{
                result[i] = 1.0 / nums.length;
            }}
        }} else {{
            for (int i = 0; i < nums.length; i++){{
                result[i] = nums[i] / sum;
            }}
        }}
        return result;
    }}

    public static void main(String[] args) {{
        int nFeatures = {n_features};
        if (args.length != nFeatures) {{
            throw new IllegalArgumentException("You have to pass " +  String.valueOf(nFeatures) + " features.");
        }}

        // Features:
        double[] features = new double[args.length];
        for (int i = 0, l = args.length; i < l; i++) {{
            features[i] = Double.parseDouble(args[i]);
        }}

        // Model data:
        {lefts}
        {rights}
        {thresholds}
        {indices}
        {classes}

        // Estimator:
        {class_name} clf = new {class_name}(lefts, rights, thresholds, indices, classes);

        // Get prediction:
        int prediction = clf.predict(features);
        System.out.println("Predicted class: #" + String.valueOf(prediction));

        // Get probabilities:
        double[] probabilities = clf.predictProba(features);
        for (int i = 0; i < probabilities.length; i++) {{
            System.out.println("Probability of class #" + i + " : " + String.valueOf((probabilities[i])));
        }}
    }}
}}