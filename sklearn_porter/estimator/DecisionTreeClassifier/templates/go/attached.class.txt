/*
This file is generated by https://github.com/nok/sklearn-porter/

Estimator:
    {estimator_name}

Documentation:
    {estimator_url}

Further usage:
    1. Compile the generated source code:
        $ go build {class_name} {class_name}.go
    2. Execute a prediction:
        $ ./{class_name} <feature_1>  ... <feature_{n_features}>
*/

package main

import (
	"fmt"
	"os"
	"strconv"
)

type {class_name} struct {{
	lefts []int
	rights []int
	thresholds []float64
	indices []int
	classes [][]int
}}

func (dtc {class_name}) {method_name}_(features []float64, node int) int {{
    if dtc.thresholds[node] != -2 {{
        if features[dtc.indices[node]] <= dtc.thresholds[node] {{
            return dtc.{method_name}_(features, dtc.lefts[node])
        }} else {{
            return dtc.{method_name}_(features, dtc.rights[node])
        }}
    }}
    var index = 0
	for i := 0; i < len(dtc.classes[node]); i++ {{
	    if dtc.classes[node][i] > dtc.classes[node][index] {{
	        index = i
	    }}
	}}
	return index
}}

func (dtc {class_name}) {method_name}(features []float64) int {{
    return dtc.{method_name}_(features, 0)
}}

func main() {{

	// Features:
	var features []float64
	for _, arg := range os.Args[1:] {{
		if n, err := strconv.ParseFloat(arg, 64); err == nil {{
			features = append(features, n)
		}}
	}}

    // Parameters:
    {lefts}
    {rights}
    {thresholds}
    {indices}
    {classes}

	// Prediction:
	clf := {class_name}{{lefts, rights, thresholds, indices, classes}}
	estimation := clf.{method_name}(features)
	fmt.Printf("%d\n", estimation)

}}